var UI_box;
var copyedSection = 0;
var checkedFlash = false;

/**
	* Array of notes showing when each section STARTS in STEPS
	* Usually rounded up??
	*/
var curSection = 0;

var eventStuff =
[
	['', "Nothing. Yep, that's right."],
	['Hey!', "Plays the \"Hey!\" animation from Bopeebo,\nValue 1: BF = Only Boyfriend, GF = Only Girlfriend,\nSomething else = Both.\nValue 2: Custom animation duration,\nleave it blank for 0.6s"],
	['Set GF Speed', "Sets GF head bopping speed,\nValue 1: 1 = Normal speed,\n2 = 1/2 speed, 4 = 1/4 speed etc.\nUsed on Fresh during the beatbox parts.\n\nWarning: Value must be integer!"],
	['Add Camera Zoom', "Used on MILF on that one \"hard\" part\nValue 1: Camera zoom add (Default: 0.015)\nValue 2: UI zoom add (Default: 0.03)\nLeave the values blank if you want to use Default."],
	['Play Animation', "Plays an animation on a Character,\nonce the animation is completed,\nthe animation changes to Idle\n\nValue 1: Animation to play.\nValue 2: Character (Dad, BF, GF)"],
	['Camera Follow Pos', "Value 1: X\nValue 2: Y\n\nThe camera won't change the follow point\nafter using this, for getting it back\nto normal, leave both values blank."],
	['Alt Idle Animation', "Sets a specified suffix after the idle animation name.\nYou can use this to trigger 'idle-alt' if you set\nValue 2 to -alt\n\nValue 1: Character to set (Dad, BF or GF)\nValue 2: New suffix (Leave it blank to disable)"],
	['Screen Shake', "Value 1: Camera shake\nValue 2: HUD shake\n\nEvery value works as the following example: \"1, 0.05\".\nThe first number (1) is the duration.\nThe second number (0.05) is the intensity."],
	['Change Character', "Value 1: Character to change (Dad, BF, GF)\nValue 2: New character's name\nValue 3: Destroy the previous character for higher performance.\n(If a previously destroyed character is reloaded, it will cause some lag)."],
	['Change Scroll Speed', "Value 1: Scroll Speed Multiplier (1 is default)\nValue 2: Time it takes to change fully in seconds."],
	['Setting Crossfades', "Value 1: Crossfade Duration\nValue 2: Crossfade Intensity\nValue 3: Crossfade Blend\nLeave the values blank if you want to use Default."]
];

var difficultyChoices = [];

var blockPressWhileTypingOn = [];
var blockPressWhileTypingOnStepper = [];
var blockPressWhileScrolling = [];

var bpmTxt;

var strumLine = null;
var curSong = 'Dadbattle';
var amountSteps = 0;
var bullshitUI;
var noteTypeText;
var highlight;
var camPos;
var CAM_OFFSET = 360;
var curEventSelected = 0;
var curDifficulty;

var zoomTxt;
var curZoom = 2;
var zoomList = [0.25, 0.5, 1, 2, 4, 8, 12, 16, 24];
//var customNoteJson:Null<Array<NoteInfo>>;

var GRID_SIZE = 40;

var dummyArrow;

var curRenderedNotes;
var curRenderedSustains;
var curRenderedNoteType;

var gridBG;

var _song;
var noteType = Normal;
var typingShit;
var player1TextField;
var player2TextField;
var gfTextField;
var cutsceneTextField;
var uiTextField;
var stageTextField;
var isAltNoteCheck;
var isCrossfade;
var customNoteNamesFile = "";
var customNoteNamesData;
var value1InputText;
var value2InputText;
var value3InputText;
var ignoreWarnings = false;
var allDiffs = [];

var playerText;
var gfText;
var enemyText;
var stageText;
var uiText;
var cutsceneText;
var coolText = new FlxText(0, 0, 0, "69", 16);
var coolBeat = new FlxText(0, 0, 0, "69", 16);

/*
	* WILL BE THE CURRENT / LAST PLACED NOTE
**/
var curSelectedNote = [];

var tempBpm = 0;

var vocals = null;
var sfxtrack = null;

var leftIcon;
var rightIcon;
var temlicon;
var temricon;

var useLiftNote = false;
var gridLayer;

var text = "";

function create()
{
	// wierd fix but might work?
	//remove(coolText);
	curSection = ChartingState.lastSection;

	var bg = new FlxSprite().loadGraphic(FNFAssets.getBitmapData(SUtil.getPath() + 'assets/images/menuDesat.png'));
	bg.scrollFactor.set();
	bg.color = 0xFF222222;
	add(bg);

	curSelectedNote = null;

	//gridBG = FlxGridOverlay.create(GRID_SIZE, GRID_SIZE, GRID_SIZE * 8, GRID_SIZE * 16);
	//add(gridBG);

	gridLayer = new FlxTypedGroup();
	add(gridLayer);

	var eventIcon = new FlxSprite((-1 * GRID_SIZE) - 5, -90).loadGraphic(FNFAssets.getGraphicData(SUtil.getPath() + 'assets/images/eventArrow.png'));
	leftIcon = new HealthIcon('bf');
	rightIcon = new HealthIcon('dad');
	leftIcon.scrollFactor.set(1, 1);
	rightIcon.scrollFactor.set(1, 1);

	eventIcon.setGraphicSize(30, 30);
	leftIcon.setGraphicSize(0, 45);
	rightIcon.setGraphicSize(0, 45);

	add(eventIcon);
	add(leftIcon);
	add(rightIcon);

	curRenderedNotes = new FlxTypedGroup();
	curRenderedSustains = new FlxTypedGroup();
	curRenderedNoteType = new FlxTypedGroup();

	if (PlayState.SONG != null)
		_song = PlayState.SONG;
	else
	{
		_song = {
			song: 'Test',
			notes: [],
			events: [],
			bpm: 150,
			needsVoices: true,
			player1: 'bf',
			player2: 'dad',
			stage: 'stage',
			gf: 'gf',
			isHey: false,
			speed: 1,
			isSpooky: false,
			isMoody: false,
			cutsceneType: "none",
			uiType: 'normal',
			isCheer: false,
			preferredNoteAmount: 4,
			forceJudgements: false,
			convertMineToNuke: false,
			mania: 0
		};
	}

	if (FNFAssets.exists(SUtil.getPath() + 'assets/images/custom_notetypes/notetypes.txt'))
	{
		customNoteNamesFile = FNFAssets.getText(SUtil.getPath() + 'assets/images/custom_notetypes/notetypes.txt');
		
		if (customNoteNamesFile != "")
			customNoteNamesData = customNoteNamesFile.split('\n');
	}

	var diffJson = CoolUtil.parseJson(FNFAssets.getJson(SUtil.getPath() + "assets/images/custom_difficulties/difficulties"));
	var diffJsonDiff = diffJson.difficulties;
	for (i in diffJsonDiff) {
		var nameDif = '-' + i.name.toLowerCase();
		if (nameDif == '-normal')
		{
			nameDif = '';
		}
		if (FNFAssets.exists(SUtil.getPath() + 'assets/data/' + PlayState.SONG.song.toLowerCase() + '/' + PlayState.SONG.song.toLowerCase() + nameDif.toLowerCase() + '.json'))
		{
			difficultyChoices.push(i.name);
		}

		allDiffs.push(i.name);
	}
	curDifficulty = allDiffs[PlayState.storyDifficulty];

	FlixG.mouse.visible = true;
	//FlxG.save.bind('save1', 'bulbyVR');
	// i don't know why we need to rebind our save
	tempBpm = _song.bpm;

	var top1 = _song.player1;
	var top2 = _song.player2;

	leftIcon.switchAnim(top1);

	rightIcon.switchAnim(top2);

	leftIcon.scrollFactor.set(1, 1);
	rightIcon.scrollFactor.set(1, 1);
	ignoreWarnings = FlixG.save.data.ignoreWarnings;

	addSection(16);

	// sections = _song.notes;

	reloadGridLayer();

	loadSong(_song.song);
	Conductor.changeBPM(_song.bpm);
	Conductor.mapBPMChanges(_song);

	bpmTxt = new FlxText(1000 + 120, 50, 0, "", 16);
	bpmTxt.scrollFactor.set();
	add(bpmTxt);
	
	// = new FlxSprite(0, 50).makeGraphic(Std.int(FlxG.width / 2), 4);
	//add(strumLine);
	camPos = new FlxObject(0, 0, 1, 1);
	camPos.setPosition(strumLine.x + CAM_OFFSET, strumLine.y);

	dummyArrow = new FlxSprite().makeGraphic(GRID_SIZE, GRID_SIZE);
	add(dummyArrow);

	var tabs = [
		{name: "Song", label: 'Song'},
		{name: "Section", label: 'Section'},
		{name: "Note", label: 'Note'},
		{name: "Events", label: 'Events'},
		{name: "Char", label: 'Char'},
		{name: "Charting", label: 'Charting'}
	];

	UI_box = new FlxUITabMenu(null, null, tabs, null, true, null, null);

	UI_box.resize(300, 400);
	UI_box.x = FlxG.width / 2 + 120;
	UI_box.y = 20;

	text =
	"W/S or Mouse Wheel - Change Conductor's strum time
	\nA or Left/D or Right - Go to the previous/next section
	\nHold Shift to move 4x faster
	\nHold Control and click on an arrow to select it
	\nZ/X - Zoom in/out
	\n
	\nEnter - Play your chart
	\nQ/E - Decrease/Increase Note Sustain Length
	\nI/O - Changes The Notetype
	\nSpace - Stop/Resume song";

	var tipTextArray = text.split('\n');
	for (i in 0...tipTextArray.length) {
		var tipText = new FlxText(UI_box.x, UI_box.y + UI_box.height + 8, 0, tipTextArray[i], 16);
		tipText.y += i * 14;
		tipText.setFormat(SUtil.getPath() + "assets/fonts/vcr.ttf", 16, 0xFFffffff, "left");
		//tipText.borderSize = 2;
		tipText.scrollFactor.set();
		add(tipText);
	}

	add(UI_box);

	noteTypeText = new FlxText(FlxG.width / 2, FlxG.height, 0, "Normal Type", 16);
	noteTypeText.x += 120;
	noteTypeText.y -= noteTypeText.height;
	noteTypeText.scrollFactor.set();
	add(noteTypeText);

	addSongUI();
	addSectionUI();
	addNoteUI();
	addEventsUI();
	addCharsUI();
	addChartingUI();


	add(curRenderedSustains);
	add(curRenderedNotes);
	add(curRenderedNoteType);
    if (vocals != null)
	vocals.play();
	changeSection(curSection, true);
	zoomTxt = new FlxText(10, 10, 0, "Zoom: 1 / 1", 16);
	zoomTxt.setBorderStyle(FlxTextBorderStyle.OUTLINE,0xFF000000,2);
	zoomTxt.scrollFactor.set();
	add(zoomTxt);

	updateGrid();
	updateHeads();
	if (mobile)
		addVirtualPad('full', 'full');
}


var stepperLength;
var stepperAltAnim;
var check_mustHitSection = null;
var check_changeBPM;
var stepperSectionBPM;
var check_altAnim;
var check_crossfadeBf;
var check_crossfadeDad;

function addSectionUI()
{
	var tab_group_section = new FlxUI(null, UI_box);
	tab_group_section.name = 'Section';

	stepperLength = new FlxUINumericStepper(10, 10, 4, 0, 0, 999, 0);
	stepperLength.value = _song.notes[curSection].lengthInSteps;
	stepperLength.name = "section_length";
	blockPressWhileTypingOnStepper.push(stepperLength);

	stepperSectionBPM = new FlxUINumericStepper(10, 80, 1, Conductor.bpm, 0, 999, 0);
	stepperSectionBPM.value = Conductor.bpm;
	stepperSectionBPM.name = 'section_bpm';
	blockPressWhileTypingOnStepper.push(stepperSectionBPM);

	stepperAltAnim = new FlxUINumericStepper(10, 200, 1, Conductor.bpm, 0, 999, 0);
	stepperAltAnim.value = 0;
	stepperAltAnim.name = 'alt_anim_number';
	blockPressWhileTypingOnStepper.push(stepperAltAnim);

	var stepperCopy = new FlxUINumericStepper(110, 130, 1, 1, -999, 999, 0);
	blockPressWhileTypingOnStepper.push(stepperCopy);

	var copyButton = new FlxButton(10, 130, "Copy last section", function()
	{
		copySection(Std.int(stepperCopy.value));
	});

	var copyCurSection = new FlxButton(210, 130, "Copy sect", function()
	{
		copyedSection = curSection;
	});

	var pasteCurSection = new FlxButton(210, 150, "Paste sect", function()
	{
		copySection(Std.int(copyedSection));
	});

	var clearSectionButton = new FlxButton(10, 150, "Clear", clearSection);

	var swapSection = new FlxButton(10, 170, "Swap section", function()
	{
		for (i in 0..._song.notes[curSection].sectionNotes.length)
		{
			var note = _song.notes[curSection].sectionNotes[i];
			if(note[1] > -1) {
				note[1] = (note[1] + Main.ammo[_song.mania]) % (Main.ammo[_song.mania] * 2);
				_song.notes[curSection].sectionNotes[i] = note;
			}
			//updateGrid();
		}
		updateGrid();
	});

	check_mustHitSection = new FlxUICheckBox(10, 30, null, null, "Must hit section", 100);
	check_mustHitSection.name = 'check_mustHit';
	check_mustHitSection.checked = true;
	// _song.needsVoices = check_mustHit.checked;

	check_altAnim = new FlxUICheckBox(10, 220, null, null, "Alt Animation", 100);
	check_altAnim.name = 'check_altAnim';

	check_crossfadeBf = new FlxUICheckBox(10, 240, null, null, "Player Crossfade", 100);
	check_crossfadeBf.name = 'check_crossfadeBf';

	check_crossfadeDad = new FlxUICheckBox(160, 240, null, null, "Opponent Crossfade", 100);
	check_crossfadeDad.name = 'check_crossfadeDad';

	check_changeBPM = new FlxUICheckBox(10, 60, null, null, 'Change BPM', 100);
	check_changeBPM.name = 'check_changeBPM';

	tab_group_section.add(stepperLength);
	tab_group_section.add(stepperSectionBPM);
	tab_group_section.add(stepperCopy);
	tab_group_section.add(copyCurSection);
	tab_group_section.add(pasteCurSection);
	tab_group_section.add(check_mustHitSection);
	tab_group_section.add(check_altAnim);
	tab_group_section.add(stepperAltAnim);
	tab_group_section.add(check_changeBPM);
	tab_group_section.add(copyButton);
	tab_group_section.add(clearSectionButton);
	tab_group_section.add(swapSection);
	tab_group_section.add(check_crossfadeBf);
	tab_group_section.add(check_crossfadeDad);


	UI_box.addGroup(tab_group_section);
}

var playSoundBf = null;
var playSoundDad = null;
var check_warnings = null;
var diffDropDown;
function addSongUI()
{
	var UI_songTitle = new FlxUIInputText(10, 10, 70, _song.song, 8);
	blockPressWhileTypingOn.push(UI_songTitle);
	typingShit = UI_songTitle;

	var check_voices = new FlxUICheckBox(10, 25, null, null, "Has voice track", 100);
	check_voices.checked = _song.needsVoices;
	// _song.needsVoices = check_voices.checked;
	check_voices.callback = function()
	{
		_song.needsVoices = check_voices.checked;
		trace('CHECKED!');
	};

	var saveButton = new FlxButton(110, 8, "Save", function()
	{
		saveLevel();
	});

	var reloadSong = new FlxButton(saveButton.x + saveButton.width + 10, saveButton.y, "Reload Audio", function()
	{
		loadSong(_song.song);
	});

	var reloadSongJson = new FlxButton(reloadSong.x, saveButton.y + 30, "Reload JSON", function()
	{
		loadJson(_song.song.toLowerCase());
	});

	var isSpookyCheck = new FlxUICheckBox(10, 280,null,null,"Is Spooky", 100);
	var loadAutosaveBtn = new FlxButton(reloadSongJson.x, reloadSongJson.y + 30, 'load autosave', loadAutosave);
	
	var loadEventJson = new FlxButton(loadAutosaveBtn.x, loadAutosaveBtn.y + 30, 'Load Events', function()
	{
		var songName = _song.song.toLowerCase();
		var file = SUtil.getPath() + 'assets/data/' + songName + '/events.json';
		if (FNFAssets.exists(file))
		{
			trace('ok this json exists! :D');
			clearEvents();
			var events = Song.loadFromJson('events', songName);
			_song.events = events.events;
			changeSection(curSection, true);
		}
	});

	var saveEvents = new FlxButton(110, reloadSongJson.y, 'Save Events', function ()
	{
		saveEvents();
	});

	var clear_events = new FlxButton(320, 310, 'Clear events', function()
	{
		openSubState(new Prompt('This action will clear current progress.\n\nProceed?', 0, clearEvents, null, ignoreWarnings));
	});
	clear_events.color = 0xFFff0000;
	clear_events.label.color = 0xFFffffff;

	var clear_notes = new FlxButton(320, clear_events.y + 30, 'Clear notes', function()
	{
		openSubState(new Prompt('This action will clear current progress.\n\nProceed?', 0, function(){for (sec in 0..._song.notes.length) {
			_song.notes[sec].sectionNotes = [];
		}
		updateGrid();
	}, null, ignoreWarnings));
		
	});
	clear_notes.color = 0xFFff0000;
	clear_notes.label.color = 0xFFffffff;
	
	var stepperSpeed = new FlxUINumericStepper(10, 100, 0.1, 1, 0.1, 10, 1);
	stepperSpeed.value = _song.speed;
	stepperSpeed.name = 'song_speed';
	blockPressWhileTypingOnStepper.push(stepperSpeed);

	var stepperBPM = new FlxUINumericStepper(10, 65, 1, 1, 1, 339, 0);
	stepperBPM.value = Conductor.bpm;
	stepperBPM.name = 'song_bpm';
	blockPressWhileTypingOnStepper.push(stepperBPM);

	diffDropDown = new FlxUIDropDownMenuCustom(10, 135, FlxUIDropDownMenuCustom.makeStrIdLabelArray(difficultyChoices, true), function(pressed)
	{
		var selectedDiff = Std.parseInt(pressed);
		curDifficulty = getDiffByArray(difficultyChoices[selectedDiff]);
	});
	diffDropDown.selectedLabel = allDiffs[PlayState.storyDifficulty];

	var stepperMania = new FlxUINumericStepper(100, 70, 1, 0, 0, 3, 1);
	stepperMania.value = _song.mania;
	stepperMania.name = 'mania';
	blockPressWhileTypingOnStepper.push(stepperMania);

	if (check_mustHitSection != null)
	updateHeads();

	var isMoodyCheck = new FlxUICheckBox(10, 220, null, null, "Is Moody", 100);
	var isHeyCheck = new FlxUICheckBox(10, 250, null, null, "Is Hey", 100);
	var isCheerCheck = new FlxUICheckBox(100, 250, null, null, "Is Cheer", 100);
	isMoodyCheck.name = "isMoody";
	isHeyCheck.name = "isHey";
	isCheerCheck.name = "isCheer";
	isSpookyCheck.name = 'isSpooky';
	isMoodyCheck.checked = _song.isMoody;
	isSpookyCheck.checked = _song.isSpooky;
	isHeyCheck.checked = _song.isHey;
	isCheerCheck.checked = _song.isCheer;
	var curStage = _song.stage;
	var tab_group_song = new FlxUI(null, UI_box);
	tab_group_song.name = "Song";
	tab_group_song.add(UI_songTitle);

	tab_group_song.add(check_voices);
	tab_group_song.add(clear_events);
	tab_group_song.add(clear_notes);
	tab_group_song.add(isMoodyCheck);
	tab_group_song.add(isSpookyCheck);
	tab_group_song.add(isHeyCheck);
	tab_group_song.add(isCheerCheck);
	tab_group_song.add(saveButton);
	tab_group_song.add(saveEvents);
	tab_group_song.add(reloadSong);
	tab_group_song.add(reloadSongJson);
	tab_group_song.add(loadAutosaveBtn);
	tab_group_song.add(loadEventJson);
	tab_group_song.add(stepperBPM);
	tab_group_song.add(stepperMania);
	tab_group_song.add(stepperSpeed);
	tab_group_song.add(diffDropDown);
	tab_group_song.add(new FlxText(stepperMania.x, stepperMania.y - 15, 0, 'Mania:'));
	tab_group_song.add(new FlxText(stepperSpeed.x, stepperSpeed.y - 15, 0, 'Song Speed:'));
	tab_group_song.add(new FlxText(diffDropDown.x, diffDropDown.y - 15, 0, 'Song Difficulty:'));

	UI_box.addGroup(tab_group_song);
	UI_box.scrollFactor.set();

	FlxG.camera.follow(camPos);
}

function getDiffByArray(daDiffName)
{
	for (i in 0...allDiffs.length)
	{
		if (allDiffs[i] == daDiffName)
			return i;
	}

	//return 4;
}

function addCharsUI()
{
	player1TextField = new FlxUIInputText(10, 100, 70, _song.player1, 8);
	blockPressWhileTypingOn.push(player1TextField);
	player2TextField = new FlxUIInputText(120, 100, 70, _song.player2, 8);
	blockPressWhileTypingOn.push(player2TextField);
	gfTextField = new FlxUIInputText(10, 120, 70, _song.gf, 8);
	blockPressWhileTypingOn.push(gfTextField);
	stageTextField = new FlxUIInputText(120, 120, 70, _song.stage, 8);
	blockPressWhileTypingOn.push(stageTextField);
	cutsceneTextField = new FlxUIInputText(120, 140, 70, _song.cutsceneType, 8);
	blockPressWhileTypingOn.push(cutsceneTextField);
	uiTextField = new FlxUIInputText(10, 140, 70, _song.uiType, 8);
	blockPressWhileTypingOn.push(uiTextField);

	playerText = new FlxText(player1TextField.x + 70, player1TextField.y, 0, "Player", 8, false);
	enemyText = new FlxText(player2TextField.x + 70, player2TextField.y, 0, "Enemy", 8, false);
	gfText = new FlxText(gfTextField.x + 70, gfTextField.y, 0, "GF", 8, false);
	stageText = new FlxText(stageTextField.x + 70, stageTextField.y, 0, "Stage", 8, false);
	cutsceneText = new FlxText(cutsceneTextField.x + 70, uiTextField.y, 0, "Cutscene", 8, false);
	uiText = new FlxText(uiTextField.x + 70, uiTextField.y, 0, "UI", 8, false);

	var curStage = _song.stage;

	var tab_group_char = new FlxUI(null, UI_box);
	tab_group_char.name = "Char";

	tab_group_char.add(playerText);
	tab_group_char.add(enemyText);
	tab_group_char.add(gfText);
	tab_group_char.add(stageText);
	tab_group_char.add(cutsceneText);
	tab_group_char.add(uiText);
	tab_group_char.add(uiTextField);
	tab_group_char.add(cutsceneTextField);
	tab_group_char.add(stageTextField);
	tab_group_char.add(gfTextField);
	tab_group_char.add(player1TextField);
	tab_group_char.add(player2TextField);

	UI_box.addGroup(tab_group_char);
	UI_box.scrollFactor.set();
}

var stepperSusLength;
var stepperAltNote;

function addNoteUI()
{
	var tab_group_note = new FlxUI(null, UI_box);
	tab_group_note.name = 'Note';

	stepperSusLength = new FlxUINumericStepper(10, 10, Conductor.stepCrochet / 2, 0, 0, Conductor.stepCrochet * 16);
	stepperSusLength.value = 0;
	stepperSusLength.name = 'note_susLength';
	blockPressWhileTypingOnStepper.push(stepperSusLength);

	var applyLength = new FlxButton(100, 10, 'Apply');
	isAltNoteCheck = new FlxUICheckBox(10, 100, null, null, "Alt Anim Note", 100);
	isAltNoteCheck.name = "isAltNote";
	stepperAltNote = new FlxUINumericStepper(10, 200, 1, 0, 0, 999, 0);
	stepperAltNote.value = 0;
	stepperAltNote.name = 'alt_anim_note';
	blockPressWhileTypingOnStepper.push(stepperAltNote);

	isCrossfade = new FlxUICheckBox(10, 120, null, null, "Cross Fade", 100);
	isCrossfade.name = "isCrossfade";

	tab_group_note.add(stepperSusLength);
	tab_group_note.add(applyLength);
	tab_group_note.add(isAltNoteCheck);
	tab_group_note.add(stepperAltNote);
	tab_group_note.add(isCrossfade);
	UI_box.addGroup(tab_group_note);


}

var eventDropDown;
var descText;
var selectedEventText;
function addEventsUI()
{
	var tab_group_event = new FlxUI(null, UI_box);
	tab_group_event.name = 'Events';

	if (sysTarget)
	{
		var eventPushedMap = new Map();
		var directories = [SUtil.getPath() + 'assets/images/custom_events/'];
		for (i in 0...directories.length) {
			var directory =  directories[i];
			if(FNFAssets.exists(directory)) 
			{	
				for (file in FileSystem.readDirectory(directory)) {
					var path = IoPath.join([directory, file]);
					if (!FileSystem.isDirectory(path) && file != 'readme.txt' && StringTools.endsWith(file, '.txt')) {
						var fileToCheck = file.substr(0, file.length - 4);
						if(!eventPushedMap.exists(fileToCheck)) {
							eventPushedMap.set(fileToCheck, true);
							eventStuff.push([fileToCheck, FNFAssets.getText(path)]);
						}
					}
				}
			}
		}
		eventPushedMap.clear();
		eventPushedMap = null;
	}
	descText = new FlxText(20, 250, 0, eventStuff[0][0]);

	var leEvents = [];
	for (i in 0...eventStuff.length) {
		leEvents.push(eventStuff[i][0]);
	}

	var text = new FlxText(20, 30, 0, "Event:");
	tab_group_event.add(text);
	eventDropDown = new FlxUIDropDownMenuCustom(20, 50, FlxUIDropDownMenuCustom.makeStrIdLabelArray(leEvents, true), function(pressed) {
		var selectedEvent = Std.parseInt(pressed);
		descText.text = eventStuff[selectedEvent][1];
		if (!arrayIsEmpty(curSelectedNote) && eventStuff != null) 
		{
			if (!arrayIsEmpty(curSelectedNote) && curSelectedNote[2] == null)
			{
				curSelectedNote[1][curEventSelected][0] = eventStuff[selectedEvent][0];
			}
			updateGrid();
		}
	});
	blockPressWhileScrolling.push(eventDropDown);

	var text = new FlxText(20, 90, 0, "Value 1:");
	tab_group_event.add(text);
	value1InputText = new FlxUIInputText(20, 110, 100, "");
	blockPressWhileTypingOn.push(value1InputText);

	var text = new FlxText(20, 130, 0, "Value 2:");
	tab_group_event.add(text);
	value2InputText = new FlxUIInputText(20, 150, 100, "");
	blockPressWhileTypingOn.push(value2InputText);

	var text = new FlxText(20, 170, 0, "Value 3:");
	tab_group_event.add(text);
	value3InputText = new FlxUIInputText(20, 190, 100, "");
	blockPressWhileTypingOn.push(value3InputText);

	// New event buttons
	var removeButton = new FlxButton(eventDropDown.x + eventDropDown.width + 10, eventDropDown.y, '-', function()
	{
		if(!arrayIsEmpty(curSelectedNote) && curSelectedNote[2] == null) //Is event note
		{
			if(curSelectedNote[1].length < 2)
			{
				_song.events.remove(curSelectedNote);
				curSelectedNote = null;
			}
			else
			{
				curSelectedNote[1].remove(curSelectedNote[1][curEventSelected]);
			}

			var eventsGroup;
			--curEventSelected;
			if(curEventSelected < 0) curEventSelected = 0;
			else if(!arrayIsEmpty(curSelectedNote) && curEventSelected >= (eventsGroup = curSelectedNote[1]).length) curEventSelected = eventsGroup.length - 1;
			
			changeEventSelected(0);
			updateGrid();
		}
	});

	removeButton.setGraphicSize(Std.int(removeButton.height), Std.int(removeButton.height));
	removeButton.updateHitbox();
	removeButton.color = 0xFFff0000;
	removeButton.label.color = 0xFFffffff;
	removeButton.label.size = 12;
	setAllLabelsOffset(removeButton, -30, 0);
	tab_group_event.add(removeButton);
		
	var addButton = new FlxButton(removeButton.x + removeButton.width + 10, removeButton.y, '+', function()
	{
		if(!arrayIsEmpty(curSelectedNote) && curSelectedNote[2] == null) //Is event note
		{
			var eventsGroup = curSelectedNote[1];
			eventsGroup.push(['', '', '']);

			changeEventSelected(1);
			updateGrid();
		}
	});

	addButton.setGraphicSize(Std.int(removeButton.width), Std.int(removeButton.height));
	addButton.updateHitbox();
	addButton.color = 0xFF00ff00;
	addButton.label.color = 0xFFffffff;
	addButton.label.size = 12;
	setAllLabelsOffset(addButton, -30, 0);
	tab_group_event.add(addButton);
		
	var moveLeftButton = new FlxButton(addButton.x + addButton.width + 20, addButton.y, '<', function()
	{
		changeEventSelected(-1);
	});
	moveLeftButton.setGraphicSize(Std.int(addButton.width), Std.int(addButton.height));
	moveLeftButton.updateHitbox();
	moveLeftButton.label.size = 12;
	setAllLabelsOffset(moveLeftButton, -30, 0);
	tab_group_event.add(moveLeftButton);
		
	var moveRightButton = new FlxButton(moveLeftButton.x + moveLeftButton.width + 10, moveLeftButton.y, '>', function()
	{
		changeEventSelected(1);
	});
	moveRightButton.setGraphicSize(Std.int(moveLeftButton.width), Std.int(moveLeftButton.height));
	moveRightButton.updateHitbox();
	moveRightButton.label.size = 12;
	setAllLabelsOffset(moveRightButton, -30, 0);
	tab_group_event.add(moveRightButton);

	selectedEventText = new FlxText(addButton.x - 100, addButton.y + addButton.height + 6, (moveRightButton.x - addButton.x) + 186, 'Selected Event: None');
	selectedEventText.alignment = 'center';
	tab_group_event.add(selectedEventText);

	tab_group_event.add(descText);
	tab_group_event.add(value1InputText);
	tab_group_event.add(value2InputText);
	tab_group_event.add(value3InputText);
	tab_group_event.add(eventDropDown);
	
	UI_box.addGroup(tab_group_event);
}

function changeEventSelected(change)
{
	if(!arrayIsEmpty(curSelectedNote) && curSelectedNote[2] == null) //Is event note
	{
		curEventSelected += change;
		if(curEventSelected < 0) curEventSelected = Std.int(curSelectedNote[1].length) - 1;
		else if(curEventSelected >= curSelectedNote[1].length) curEventSelected = 0;
		selectedEventText.text = 'Selected Event: ' + (curEventSelected + 1) + ' / ' + curSelectedNote[1].length;
	}
	else
	{
		curEventSelected = 0;
		selectedEventText.text = 'Selected Event: None';
	}
	updateNoteUI();
}

function setAllLabelsOffset(button, x, y)
{
	for (point in button.labelOffsets)
	{
		point.set(x, y);
	}
}

var instVolume;
var voicesVolume;
function addChartingUI()
{
	var tab_group_chart = new FlxUI(null, UI_box);
	tab_group_chart.name = 'Charting';

	var check_mute_inst = new FlxUICheckBox(10, 200, null, null, "Mute Instrumental (in editor)", 100);
	check_mute_inst.checked = false;
	check_mute_inst.callback = function()
	{
		var vol = 1;

		if (check_mute_inst.checked)
			vol = 0;

		FlxG.sound.music.volume = vol;
	};

	check_warnings = new FlxUICheckBox(10, 120, null, null, "Ignore Progress Warnings", 100);
	if (FlixG.save.data.ignoreWarnings == null) FlixG.save.data.ignoreWarnings = false;
	check_warnings.checked = FlixG.save.data.ignoreWarnings;

	check_warnings.callback = function()
	{
		FlixG.save.data.ignoreWarnings = check_warnings.checked;
		ignoreWarnings = FlixG.save.data.ignoreWarnings;
	};

	var check_mute_vocals = new FlxUICheckBox(check_mute_inst.x + 120, check_mute_inst.y, null, null, "Mute Vocals (in editor)", 100);
	check_mute_vocals.checked = false;
	check_mute_vocals.callback = function()
	{
		if(vocals != null) {
			var vol = 1;

			if (check_mute_vocals.checked)
				vol = 0;

			vocals.volume = vol;
		}
	};

	playSoundBf = new FlxUICheckBox(check_mute_inst.x, check_mute_vocals.y + 30, null, null, 'Play Sound (Player notes)', 100,
		function() {
			FlixG.save.data.chart_playSoundBf = playSoundBf.checked;
		}
	);
	if (FlixG.save.data.chart_playSoundBf == null) FlixG.save.data.chart_playSoundBf = false;
	playSoundBf.checked = FlixG.save.data.chart_playSoundBf;

	playSoundDad = new FlxUICheckBox(check_mute_inst.x + 120, playSoundBf.y, null, null, 'Play Sound (Opponent notes)', 100,
		function() {
			FlixG.save.data.chart_playSoundDad = playSoundDad.checked;
		}
	);
	if (FlixG.save.data.chart_playSoundDad == null) FlixG.save.data.chart_playSoundDad = false;
	playSoundDad.checked = FlixG.save.data.chart_playSoundDad;

	instVolume = new FlxUINumericStepper(15, 270, 0.1, 1, 0, 1, 1);
	instVolume.value = FlxG.sound.music.volume;
	instVolume.name = 'inst_volume';
	blockPressWhileTypingOnStepper.push(instVolume);

	voicesVolume = new FlxUINumericStepper(instVolume.x + 100, instVolume.y, 0.1, 1, 0, 1, 1);
	if(vocals != null) 
	voicesVolume.value = vocals.volume;
	else
	voicesVolume.value = 0;
	voicesVolume.name = 'voices_volume';
	blockPressWhileTypingOnStepper.push(voicesVolume);

	tab_group_chart.add(new FlxText(instVolume.x, instVolume.y - 15, 0, 'Inst Volume'));
	tab_group_chart.add(new FlxText(voicesVolume.x, voicesVolume.y - 15, 0, 'Voices Volume'));
	tab_group_chart.add(check_mute_inst);
	tab_group_chart.add(check_mute_vocals);
	tab_group_chart.add(check_warnings);
	tab_group_chart.add(playSoundBf);
	tab_group_chart.add(playSoundDad);
	tab_group_chart.add(instVolume);
	tab_group_chart.add(voicesVolume);
	UI_box.addGroup(tab_group_chart);
}
function changeKeyType(change) {
	noteType += change;
	noteType = FlxMath.wrap(noteType, 0, 99);
	switch (noteType)
	{
		case Normal:
			noteTypeText.text = "Normal Note";
		case Lift:
			noteTypeText.text = "Lift Note";
		case Mine:
			noteTypeText.text = "Mine Note";
		case Death:
			noteTypeText.text = "Death Note";
		case 4:
			// drain
			noteTypeText.text = "Drain Note";
		default:
			if (customNoteNamesFile != "" && noteType - 5 < customNoteNamesData.length)
				noteTypeText.text = customNoteNamesData[noteType - 5];
			else
				noteTypeText.text = 'Custom Note' + (noteType - 4);
	}
}

function loadSong(daSong)
{
	if (FlxG.sound.music != null)
	{
		FlxG.sound.music.stop();
		// vocals.stop();
	}

	// WONT WORK FOR TUTORIAL OR TEST SONG!!! REDO LATER
	if (_song.needsVoices) {
		if (sysTarget)
		{
			var vocalSound = FNFAssets.getSound(SUtil.getPath() + "assets/music/"+daSong+"_Voices"+TitleState.soundExt);
			vocals = new FlxSound().loadEmbedded(vocalSound);
		}
		else
			vocals = new FlxSound().loadEmbedded(SUtil.getPath() + "assets/music/" + daSong + "_Voices" + TitleState.soundExt);
		
		FlxG.sound.list.add(vocals);
	}

	if (FNFAssets.exists(SUtil.getPath() + 'assets/music/' + daSong + "_Sounds" + TitleState.soundExt))
	{
		if (sysTarget)
		{
			var sfxSound = FNFAssets.getSound(SUtil.getPath() + "assets/music/"+daSong+"_Sounds"+TitleState.soundExt);
			sfxtrack = new FlxSound().loadEmbedded(sfxSound);
		}
		else
			sfxtrack = new FlxSound().loadEmbedded(SUtil.getPath() + "assets/music/" + daSong + "_Sounds" + TitleState.soundExt);
		
		FlxG.sound.list.add(sfxtrack);
	}

	if (sysTarget)
		FlxG.sound.playMusic(FNFAssets.getSound(SUtil.getPath() + "assets/music/"+daSong+"_Inst"+TitleState.soundExt), 0.6);
	else
		FlxG.sound.playMusic(SUtil.getPath() + 'assets/music/' + daSong + "_Inst" + TitleState.soundExt, 0.6);

	if (instVolume != null) FlxG.sound.music.volume = instVolume.value;
	
	FlxG.sound.music.pause();
	if (_song.needsVoices) {
		vocals.pause();
	}

	if (sfxtrack != null)
		sfxtrack.pause();

	FlxG.sound.music.onComplete = function()
	{
		if (_song.needsVoices) {
			vocals.pause();
			vocals.time = 0;
		}

		if (sfxtrack != null)
		{
			sfxtrack.pause();
			sfxtrack.time = 0;
		}

		FlxG.sound.music.pause();
		FlxG.sound.music.time = 0;
		changeSection(0, true);
	};
}

function generateUI()
{
	while (bullshitUI.members.length > 0)
	{
		bullshitUI.remove(bullshitUI.members[0], true);
	}

	// general shit
	var title = new FlxText(UI_box.x + 20, UI_box.y + 20, 0);
	bullshitUI.add(title);
}

function getEvent(id, sender, data, params)
{
	if (id == "click_check_box")
	{
		var check = sender;
		var label = check.getLabel().text;
		switch (label)
		{
			case 'Must hit section':
				_song.notes[curSection].mustHitSection = check.checked;

				updateHeads();

			case 'Change BPM':
				_song.notes[curSection].changeBPM = check.checked;
				FlixG.log.add('changed bpm shit');
			case "Alt Animation":
				_song.notes[curSection].altAnim = check.checked;
			case "Is Moody":
				_song.isMoody = check.checked;
			case "Is Spooky":
				_song.isSpooky = check.checked;
			case "Is Hey":
				_song.isHey = check.checked;
			case 'Alt Anim Note':
				if (!arrayIsEmpty(curSelectedNote) && curSelectedNote[1] > -1) {
					var tempCheck = 0;
					if (check.checked) tempCheck = 1;
					
					curSelectedNote[3] = tempCheck;
					updateNoteUI();
				}
				else
				{
					sender.value = false;
				}
			case 'Is Cheer':
				_song.isCheer = check.checked;
			case 'Cross Fade':
				if (!arrayIsEmpty(curSelectedNote) && curSelectedNote[1] > -1) {
					curSelectedNote[12] = check.checked;
					updateNoteUI();
				}
				else
				{
					sender.value = false;
				}
			case 'Player Crossfade':
				_song.notes[curSection].crossfadeBf = check.checked;
			case 'Opponent Crossfade':
				_song.notes[curSection].crossfadeDad = check.checked;
		}
	}
	else if (id == "change_numeric_stepper" /*&& isNumericStepper(sender)*/)
	{
		var nums = sender;
		var wname = nums.name;
		FlixG.log.add(wname);
		if (wname == 'section_length')
		{
			_song.notes[curSection].lengthInSteps = Std.int(nums.value);
			updateGrid();
		}
		else if (wname == 'song_speed')
		{
			_song.speed = nums.value;
		}
		else if (wname == 'song_bpm')
		{
			tempBpm = nums.value;
			Conductor.mapBPMChanges(_song);
			Conductor.changeBPM(nums.value);
		}
		else if (wname == 'note_susLength')
		{
			if(!arrayIsEmpty(curSelectedNote) && curSelectedNote[1] > -1) {
				curSelectedNote[2] = nums.value;
				updateGrid();
			} else {
				sender.value = 0;
			}
		}
		else if (wname == 'section_bpm')
		{
			_song.notes[curSection].bpm = nums.value;
			updateGrid();
		} else if (wname == 'alt_anim_number')
		{
			_song.notes[curSection].altAnimNum = Std.int(nums.value);
		}  else if (wname == 'alt_anim_note') {
			if (!arrayIsEmpty(curSelectedNote))
				curSelectedNote[3] = nums.value;
			updateNoteUI();
		}
		else if (wname == 'inst_volume')
		{
			FlxG.sound.music.volume = nums.value;
		}
		else if (wname == 'voices_volume')
		{
			vocals.volume = nums.value;
		}
		else if (wname == 'mania')
		{
			_song.mania = Std.int(nums.value);
			reloadGridLayer();
			updateHeads();
		}
	}
	else if(id == "change_input_text" /*&& isInputText(sender)*/) {
		if(!arrayIsEmpty(curSelectedNote))
		{
			if(sender == value1InputText) {
				curSelectedNote[1][curEventSelected][1] = value1InputText.text;
				updateGrid();
			}
			else if(sender == value2InputText) {
				curSelectedNote[1][curEventSelected][2] = value2InputText.text;
				updateGrid();
			}
			else if(sender == value3InputText) {
				curSelectedNote[1][curEventSelected][3] = value3InputText.text;
				updateGrid();
			}
		}
	}

	// FlxG.log.add(id + " WEED " + sender + " WEED " + data + " WEED " + params);
}

var updatedSection = false;

function sectionStartTime(add)
{
	var daBPM = _song.bpm;
	var daPos = 0;
	for (i in 0...curSection + add)
	{
		if(_song.notes[i] != null)
		{
			if (_song.notes[i].changeBPM)
			{
				daBPM = _song.notes[i].bpm;
			}
			daPos += 4 * (1000 * 60 / daBPM);
		}
	}
	return daPos;
}

var colorSine = 0;
var lastConductorPos;
function update(elapsed)
{
	if (FlxG.keys.justPressed.ENTER || (mobile && visPressed('A')))
		{
			ChartingState.lastSection = curSection;
	
			PlayState.SONG = _song;
			FlxG.sound.music.stop();
			if (_song.needsVoices) {
				vocals.stop();
			}
	
			if (sfxtrack != null)
				sfxtrack.stop();
	
			FlixG.mouse.visible = false;
			LoadingState.loadAndSwitchState(new PlayState());
		}

	curStep = recalculateSteps();

	var ctrlPressed = FlxG.keys.pressed.CONTROL;

	var gWidth = GRID_SIZE * (Main.ammo[_song.mania] * 2);
	camPos.x = -80 + gWidth;
	strumLine.width = gWidth;
	//rightIcon.x = gWidth / 2 + GRID_SIZE * 2;

	/*if (controls.BACK)
	{
		FlixG.resetState();
	}*/

	remove(coolText);
	coolText.text = 'curStep: ' + Std.string(curStep);
	coolText.x = 1000 + 120;
	coolText.y = 100;
	coolText.scrollFactor.set();
	add(coolText);

	remove(coolBeat);
	coolBeat.text = 'curBeat: ' + Std.string(instance.curBeat);
	coolBeat.x = 1000 + 120;
	coolBeat.y = 120;
	coolBeat.scrollFactor.set();
	add(coolBeat);

	Conductor.songPosition = FlxG.sound.music.time;
	_song.song = typingShit.text;
	_song.player1 = player1TextField.text;
	_song.player2 = player2TextField.text;
	_song.gf = gfTextField.text;
	_song.stage = stageTextField.text;
	_song.cutsceneType = cutsceneTextField.text;
	_song.uiType = uiTextField.text;
	strumLine.y = getYfromStrum((Conductor.songPosition - sectionStartTime(0)) / zoomList[curZoom]  % (Conductor.stepCrochet * _song.notes[curSection].lengthInSteps),true);
	camPos.y = strumLine.y;

	var top1 = _song.player1;
	var top2 = _song.player2;

	if (PlayState.SONG.song.toLowerCase() == 'intermission')
	{
		if (instance.curStep >= 272)
			top2 = 'carol-core';
		if (instance.curStep >= 432)
			top2 = 'kapi-core';
		if (instance.curStep >= 656)
			top2 = 'sunday-sp';
		if (instance.curStep >= 1104)
			top2 = 'carol-core';
		if (instance.curStep >= 1160)
			top2 = 'sunday-sp';
		if (instance.curStep >= 1232)
			top2 = 'carol-core';
		if (instance.curStep >= 1328)
			top2 = 'sunday-sp';
		if (instance.curStep >= 1360)
			top2 = 'kapi-core';
		if (instance.curStep >= 1416)
			top2 = 'sunday-sp';
	}

	if (temlicon != top1)
	{
		temlicon = top1;
		leftIcon.switchAnim(temlicon);
	}
	
	if (temricon != top2)
	{
		temricon = top2;
		rightIcon.switchAnim(temricon);/*_song.player2);*/
	}

	if (curBeat % 4 == 0 && curStep >= 16 * (curSection + 1))
	{
		if (_song.notes[curSection + 1] == null)
		{
			addSection(16);
		}

		changeSection(curSection + 1, false);
	}
	else if(strumLine.y < -10) {
		changeSection(curSection - 1, false);
	}

	FlixG.watch.addQuick('daBeat', curBeat);
	FlixG.watch.addQuick('daStep', curStep);

	if (FlixG.mouse.justPressed)
	{
		if (FlixG.mouse.overlaps(curRenderedNotes))
		{
			curRenderedNotes.forEach(function(note)
			{
				if (FlixG.mouse.overlaps(note))
				{
					if (ctrlPressed)
					{
						selectNote(note);
					}
					else
					{
						trace('tryin to delete note...');
						deleteNote(note);
					}
				}
			});
		}
		else
		{
			if (FlixG.mouse.x > gridBG.x
				&& FlixG.mouse.x < gridBG.x + gridBG.width
				&& FlixG.mouse.y > gridBG.y
				&& FlixG.mouse.y < gridBG.y + (GRID_SIZE * _song.notes[curSection].lengthInSteps) * zoomList[curZoom])
			{
				FlixG.log.add('added note');
				addNote();
			}
		}
	}

	if (FlixG.mouse.x > gridBG.x
		&& FlixG.mouse.x < gridBG.x + gridBG.width
		&& FlixG.mouse.y > gridBG.y
		&& FlixG.mouse.y < gridBG.y + (GRID_SIZE * _song.notes[curSection].lengthInSteps) * zoomList[curZoom])
	{
		dummyArrow.x = Math.floor(FlixG.mouse.x / GRID_SIZE) * GRID_SIZE;
		if (FlxG.keys.pressed.SHIFT || (mobile && visPressed('B')))
			dummyArrow.y = FlixG.mouse.y;
		else
			dummyArrow.y = Math.floor(FlixG.mouse.y / GRID_SIZE) * GRID_SIZE;
	}

	
	

	if (!arrayIsEmpty(curSelectedNote) && curSelectedNote[1] > -1) {
		if (FlxG.keys.justPressed.E || (mobile && visPressed('X')))
			{
				changeNoteSustain(Conductor.stepCrochet);
			}
			if (FlxG.keys.justPressed.Q || (mobile && visPressed('C')))
			{
				changeNoteSustain(-Conductor.stepCrochet);
			}
	}

	if (FlxG.keys.justPressed.TAB)
	{
		if (FlxG.keys.pressed.SHIFT|| (mobile && visPressed('B')))
		{
			UI_box.selected_tab -= 1;
			if (UI_box.selected_tab < 0)
				UI_box.selected_tab = 5;
		}
		else
		{
			UI_box.selected_tab += 1;
			if (UI_box.selected_tab >= 6)
				UI_box.selected_tab = 0;
		}
	}

	var blockInput = false;
	for (inputText in blockPressWhileTypingOn) {
		if(inputText.hasFocus) {
			FlixG.sound.muteKeys = [];
			FlixG.sound.volumeDownKeys = [];
			FlixG.sound.volumeUpKeys = [];
			blockInput = true;
			break;
		}
	}

	if(!blockInput) {
		for (stepper in blockPressWhileTypingOnStepper) {
			var leText = getStepperTextField(stepper);
			if(leText.hasFocus) {
				FlixG.sound.muteKeys = [];
				FlixG.sound.volumeDownKeys = [];
				FlixG.sound.volumeUpKeys = [];
				blockInput = true;
				break;
			}
		}
	}

	if(!blockInput) {
		FlixG.sound.muteKeys = TitleState.muteKeys;
		FlixG.sound.volumeDownKeys = TitleState.volumeDownKeys;
		FlixG.sound.volumeUpKeys = TitleState.volumeUpKeys;
		for (dropDownMenu in blockPressWhileScrolling) {
			if(dropDownMenu.dropPanel.visible) {
				blockInput = true;
				break;
			}
		}
	}

	var shiftThing = 1;
	if (!blockInput)
	{
		if (FlxG.keys.justPressed.SPACE || (mobile && visPressed('Z')))
		{
			if (FlxG.sound.music.playing)
			{
				FlxG.sound.music.pause();
				if (_song.needsVoices) {
					vocals.pause();
				}

				if (sfxtrack != null)
					sfxtrack.pause();

			}
			else
			{
				if (_song.needsVoices) {
					vocals.play();
				}
				FlxG.sound.music.play();

				if (sfxtrack != null)
					sfxtrack.play();
			}
		}

		if (FlxG.keys.justPressed.R || (mobile && visPressed('Y')))
			{
				if (FlxG.keys.pressed.SHIFT|| (mobile && visPressed('B')))
				resetSection(true);
			else
				resetSection(false);
		}

		if (FlixG.mouse.wheel != 0)
		{
			FlxG.sound.music.pause();
			if (_song.needsVoices) {
				vocals.pause();
			}

			if (sfxtrack != null)
				sfxtrack.pause();

			FlxG.sound.music.time -= (FlixG.mouse.wheel * Conductor.stepCrochet * 0.4);
			if (_song.needsVoices) {
				vocals.time = FlxG.sound.music.time;
			}

			if (sfxtrack != null)
				sfxtrack.time = FlxG.sound.music.time;

		}
		if (FlxG.keys.pressed.SHIFT|| (mobile && visPressed('B')))
			shiftThing = 4;

		if (FlxG.keys.justPressed.RIGHT || FlxG.keys.justPressed.D || (mobile && visPressed('buttonRight')))
			changeSection(curSection + shiftThing, true);
		if (FlxG.keys.justPressed.LEFT || FlxG.keys.justPressed.A || (mobile && visPressed('buttonLeft')))
			changeSection(curSection - shiftThing, true);
		
		if(FlixG.keys.justPressed.Z && curZoom > 0 && !ctrlPressed) {
			curZoom -= 1;
			updateZoom();
		}
		if(FlixG.keys.justPressed.X && curZoom < zoomList.length-1) {
			curZoom += 1;
			updateZoom();
		}
		
		if (!FlxG.keys.pressed.SHIFT|| (mobile && visPressed('B')))
		{
			if (FlxG.keys.pressed.W || (mobile && visPressed('buttonUp')) || FlxG.keys.pressed.S || (mobile && visPressed('buttonDown')))
			{
				FlxG.sound.music.pause();
				if (_song.needsVoices) {
					vocals.pause();
				}

				if (sfxtrack != null)
					sfxtrack.pause();

				var daTime = 700 * FlxG.elapsed;

				if (FlxG.keys.pressed.W || (mobile && visPressed('buttonUp')))
				{
					FlxG.sound.music.time -= daTime;
				}
				else
					FlxG.sound.music.time += daTime;
				if (_song.needsVoices) {
					vocals.time = FlxG.sound.music.time;
				}

				if (sfxtrack != null)
					sfxtrack.time = FlxG.sound.music.time;

			}
		}
		else
		{
			if (FlxG.keys.pressed.W || (mobile && visPressed('buttonUp')) || FlxG.keys.pressed.S || (mobile && visPressed('buttonDown')))
			{
				FlxG.sound.music.pause();
				if (_song.needsVoices) {
					vocals.pause();
				}

				if (sfxtrack != null)
					sfxtrack.pause();

				var daTime = Conductor.stepCrochet * 2;

				if (FlxG.keys.justPressed.W || (mobile && visPressed('buttonUp')))
				{
					FlxG.sound.music.time -= daTime;
				}
				else
					FlxG.sound.music.time += daTime;
				if (_song.needsVoices) {
					vocals.time = FlxG.sound.music.time;
				}

				if (sfxtrack != null)
					sfxtrack.time = FlxG.sound.music.time;

			}
		}

		if (FlxG.keys.justPressed.I || (mobile && visPressed('V'))) {
			changeKeyType(-1);
		} else if (FlxG.keys.justPressed.O || (mobile && visPressed('D'))) {
			changeKeyType(1);
		}

	} else if (FlxG.keys.justPressed.ENTER || (mobile && visPressed('A'))) {
		for (i in 0...blockPressWhileTypingOn.length) {
			if(blockPressWhileTypingOn[i].hasFocus) {
				blockPressWhileTypingOn[i].hasFocus = false;
			}
		}
	}

	_song.bpm = tempBpm;

	bpmTxt.text = bpmTxt.text = Std.string(FlxMath.roundDecimal(Conductor.songPosition / 1000, 2))
		+ " / "
		+ Std.string(FlxMath.roundDecimal(FlxG.sound.music.length / 1000, 2))
		+ "\nSection: "
		+ curSection;

	var playedSound = [false, false, false, false]; //Prevents ouchy GF sex sounds
	curRenderedNotes.forEachAlive(function(note)
	{
		note.alpha = 1;
		if (note.strumTime <= Conductor.songPosition) 
		{
			note.alpha = 0.4;
			if (note.strumTime > lastConductorPos && FlxG.sound.music.playing && note.noteData > -1) 
			{
				var data = note.noteData % 4;
				if(!playedSound[data]) {
					if ((playSoundBf.checked && note.mustPress) || (playSoundDad.checked && !note.mustPress))
					{
						var soundToPlay = 'hitSound';
						if(_song.player1 == 'gf' && _song.mania == 0) { //Easter egg
							soundToPlay = 'GF_' + Std.string(data + 1);
						}
						var tempPan = 0.3;
						if (note.noteData < 4) tempPan = -0.3;
						FlxG.sound.play(FNFAssets.getSound(SUtil.getPath() + 'assets/sounds/' + soundToPlay + '.ogg')).pan = tempPan; //would be coolio
						playedSound[data] = true;
					}
				
					data = note.noteData;
					if(note.mustPress != _song.notes[curSection].mustHitSection)
					{
						data += 4;
					}
				}
			}
		}
	});
	
	lastConductorPos = Conductor.songPosition;
}

function updateZoom() {
	var daZoom = zoomList[curZoom];
	var zoomThing = '1 / ' + daZoom;
	if(daZoom < 1) zoomThing = Math.round(1 / daZoom) + ' / 1';
	zoomTxt.text = 'Zoom: ' + zoomThing;
	reloadGridLayer();
}

function reloadGridLayer() {
	gridLayer.clear();
	gridBG = FlxGridOverlay.create(GRID_SIZE, GRID_SIZE, GRID_SIZE * (Main.ammo[_song.mania] * 2 + 1), Std.int(GRID_SIZE * 16 * zoomList[curZoom]));
	gridLayer.add(gridBG);

	//var gridBlack:FlxSprite = new FlxSprite(0, gridBG.height / 2).makeGraphic(Std.int(GRID_SIZE + GRID_SIZE * Main.ammo[_song.mania] * 2), Std.int(gridBG.height / 2), FlxColor.BLACK);
	//gridBlack.alpha = 0.4;
	//gridLayer.add(gridBlack);

	var gridBlackLine = new FlxSprite(gridBG.x + gridBG.width - (GRID_SIZE * Main.ammo[_song.mania])).makeGraphic(2, Std.int(gridBG.height), 0xFF000000);
	gridLayer.add(gridBlackLine);

	var gridBlackLine = new FlxSprite(gridBG.x + GRID_SIZE).makeGraphic(2, Std.int(gridBG.height), 0xFF000000);
	gridLayer.add(gridBlackLine);

	if (strumLine != null)
		remove(strumLine);
	
	strumLine = new FlxSprite(0, 50).makeGraphic(Std.int(GRID_SIZE + ((GRID_SIZE) * (Main.ammo[_song.mania] * 2))), 4);
	
	add(strumLine);

	updateGrid();
	
}

function changeNoteSustain(value)
{
	if (!arrayIsEmpty(curSelectedNote))
	{
		if (curSelectedNote[2] != null)
		{
			curSelectedNote[2] += value;
			curSelectedNote[2] = Math.max(curSelectedNote[2], 0);
		}
	}

	updateNoteUI();
	updateGrid();
}

function toggleNoteAnim() {
	if (!arrayIsEmpty(curSelectedNote)) {
		if (curSelectedNote[2] != null)
		{
			if (curSelectedNote[3] != null) {
				var tempCyc = 1;
				if (curSelectedNote[3] == 1) tempCyc = 0;
				curSelectedNote[3] = tempCyc;

			} else {
				curSelectedNote[3] = 1;
			}
		}
	}
	updateNoteUI();
}

function recalculateSteps()
{
	var lastChange = {
		stepTime: 0,
		songTime: 0,
		bpm: 0
	}
	
	for (i in 0...Conductor.bpmChangeMap.length)
	{
		if (FlixG.sound.music.time > Conductor.bpmChangeMap[i].songTime)
			lastChange = Conductor.bpmChangeMap[i];
	}

	instance.curStep = lastChange.stepTime + Math.floor((FlixG.sound.music.time - lastChange.songTime) / Conductor.stepCrochet);
	instance.updateBeat();

	return instance.curStep;
}

function resetSection(songBeginning)
{
	updateGrid();

	FlxG.sound.music.pause();
	if (_song.needsVoices) {
		vocals.pause();
	}

	if (sfxtrack != null)
		sfxtrack.pause();

	// Basically old shit from changeSection???
	FlxG.sound.music.time = sectionStartTime(0);

	if (songBeginning)
	{
		FlxG.sound.music.time = 0;
		curSection = 0;
	}
	if (_song.needsVoices) {
		vocals.time = FlxG.sound.music.time;
	}

	if (sfxtrack != null)
		sfxtrack.time = FlxG.sound.music.time;

	//updateCurStep();

	updateGrid();
	updateSectionUI();
}

function changeSection(sec, updateMusic)
{
	trace('changing section' + sec);

	if (_song.notes[sec] != null)
	{
		curSection = sec;

		updateGrid();

		if (updateMusic)
		{
			FlxG.sound.music.pause();
			
			FlxG.sound.music.time = sectionStartTime(0);
			
			if (_song.needsVoices) {
				vocals.pause();
				vocals.time = FlxG.sound.music.time;
			}

			if (sfxtrack != null)
			{
				sfxtrack.pause();
				sfxtrack.time = FlxG.sound.music.time;
			}

			//updateCurStep();
		}

		updateGrid();
		updateSectionUI();
	}
	else
	{
		changeSection(0, true);
	}
	Conductor.songPosition = FlxG.sound.music.time;
}

function copySection(sectionNum)
{
	var daSec = FlxMath.maxInt(curSection, sectionNum);

	for (note in _song.notes[daSec - sectionNum].sectionNotes)
	{
		var strum = note[0] + Conductor.stepCrochet * (_song.notes[daSec].lengthInSteps * sectionNum);

		var copiedNote = [strum, note[1], note[2]];
		_song.notes[daSec].sectionNotes.push(copiedNote);
	}

	updateGrid();
}

function updateSectionUI()
{
	var sec = _song.notes[curSection];

	if (sec.lengthInSteps == null)
		sec.lengthInSteps = 16;

	stepperLength.value = sec.lengthInSteps;

	check_mustHitSection.checked = sec.mustHitSection;
	check_altAnim.checked = sec.altAnim;

	if (check_crossfadeBf.checked == null)
		check_crossfadeBf.checked = false;
	else
		check_crossfadeBf.checked = sec.crossfadeBf;

	if (check_crossfadeDad.checked == null)
		check_crossfadeDad.checked = false;
	else
		check_crossfadeDad.checked = sec.crossfadeDad;

	check_changeBPM.checked = sec.changeBPM;
	// note that 0 implies regular anim and 1 implies default alt 
	if (sec.altAnimNum == null) {
		var tempAlt = 0;
		if (sec.altAnim) tempAlt = 1;
		sec.altAnimNum == tempAlt;
	}
	stepperAltAnim.value = sec.altAnimNum;
	stepperSectionBPM.value = sec.bpm;

	updateHeads();
}

function updateHeads()
{
	var sustr = Main.ammo[_song.mania] - 4;
	var maniaSep = (GRID_SIZE * (sustr / 2));

	var daSpace = 26;
	
	if (check_mustHitSection.checked)
	{
		leftIcon.setPosition((GRID_SIZE / 2) + daSpace + maniaSep, -100);
		rightIcon.setPosition((gridBG.width / 2) + daSpace + maniaSep, -100);
	}
	else
	{
		rightIcon.setPosition((GRID_SIZE / 2) + daSpace + maniaSep, -100);
		leftIcon.setPosition((gridBG.width / 2) + daSpace + maniaSep, -100);
	}
}

function updateNoteUI()
{
	if (!arrayIsEmpty(curSelectedNote)) 
	{
		if(curSelectedNote[2] != null) 
		{
			stepperSusLength.value = curSelectedNote[2];
			// null is falsy
			isAltNoteCheck.checked = curSelectedNote[3];
			var tempSus = 0;
			if (curSelectedNote[3] != null) tempSus = curSelectedNote[3];
			stepperAltNote.value = tempSus;
			isCrossfade.checked = curSelectedNote[12];
		}
		else
		{
			eventDropDown.selectedLabel = curSelectedNote[1][curEventSelected][0];
			var selected = Std.parseInt(eventDropDown.selectedId);
			if(selected > 0 && selected < eventStuff.length) {
				descText.text = eventStuff[selected][1];
			}
			value1InputText.text = curSelectedNote[1][curEventSelected][1];
			value2InputText.text = curSelectedNote[1][curEventSelected][2];
			value3InputText.text = curSelectedNote[1][curEventSelected][3];
		}
			//strumTimeInputText.text = '' + curSelectedNote[0];
	}
		

}

function updateGrid()
{
	
	//curRenderedNoteType.clear();
	
	while (curRenderedNotes.members.length > 0)
	{
		curRenderedNotes.remove(curRenderedNotes.members[0], true);
	}

	while (curRenderedSustains.members.length > 0)
	{
		curRenderedSustains.remove(curRenderedSustains.members[0], true);
	}

	while (curRenderedNoteType.members.length > 0)
	{
		curRenderedNoteType.remove(curRenderedNoteType.members[0], true);
	}

	//var sectionInfo:Array<Dynamic> = _song.notes[curSection].sectionNotes;

	if (_song.notes[curSection].changeBPM && _song.notes[curSection].bpm > 0)
	{
		Conductor.changeBPM(_song.notes[curSection].bpm);
		//FlxG.log.add('CHANGED BPM!');
	}
	else
	{
		//get last bpm
		var daBPM = _song.bpm;
		for (i in 0...curSection)
			if (_song.notes[i].changeBPM)
				daBPM = _song.notes[i].bpm;
		Conductor.changeBPM(daBPM);
	}

	//var yummyPng = FNFAssets.getBitmapData(SUtil.getPath() + 'assets/images/custom_ui/ui_packs/normal/NOTE_assets.png');
	//var yummyXml = FNFAssets.getText(SUtil.getPath() + 'assets/images/custom_ui/ui_packs/normal/NOTE_assets.xml');
	
	for (i in _song.notes[curSection].sectionNotes)
	{

		var note = setupNoteData(i);
		curRenderedNotes.add(note);

		if (note.sustainLength > 0)
		{
			var sustainVis = setupSusNote(note);
		
			curRenderedSustains.add(sustainVis);
		}

		note.mustPress = _song.notes[curSection].mustHitSection;
		if(i[1] > Main.ammo[_song.mania] - 1) note.mustPress = !note.mustPress;

	}

	// CURRENT EVENTS
	var startThing = sectionStartTime(0);
	var endThing = sectionStartTime(1);

	if (_song.events != null && _song.events.length > 0)
	{
		for (i in _song.events)
		{
			if(endThing > i[0] && i[0] >= startThing)
			{
				var note = setupNoteData(i);
				curRenderedNotes.add(note);
				
				if(note.y < -150) note.y = -150;

				var text = 'Event: ' + note.eventName + ' (' + Math.floor(note.strumTime) + ' ms)' + '\nValue 1: ' + note.eventVal1 + '\nValue 2: ' + note.eventVal2;
				if(note.eventLength > 1) text = note.eventLength + ' Events:\n' + note.eventName;

				var daText = new AttachedFlxText(0, 0, 400, text, 12);
				daText.setFormat(SUtil.getPath() + "assets/fonts/vcr.ttf", 12, 0xFFffffff, "right", FlxTextBorderStyle.OUTLINE_FAST, 0xFF000000);
				daText.xAdd = -410;
				daText.borderSize = 1;
				if(note.eventLength > 1) daText.yAdd += 8;
				curRenderedNoteType.add(daText);
				daText.sprTracker = note;
				//trace('test: ' + i[0], 'startThing: ' + startThing, 'endThing: ' + endThing);
			}
		}
	}
}

function setupSusNote(note) {
	var height = Math.floor(FlxMath.remapToRange(note.sustainLength, 0, Conductor.stepCrochet * 16, 0, GRID_SIZE * 16 * zoomList[curZoom]) + (GRID_SIZE * zoomList[curZoom]) - GRID_SIZE / 2);
	var minHeight = Std.int((GRID_SIZE * zoomList[curZoom] / 2) + GRID_SIZE / 2);
	if(height < minHeight) height = minHeight;
	if(height < 1) height = 1; //Prevents error of invalid height

	var spr = new FlxSprite(note.x + (GRID_SIZE * 0.5) - 4, note.y + GRID_SIZE / 2).makeGraphic(8, height);
	return spr;
}

function setupNoteData(i)
{
	var daNoteInfo = i[1];
	var daStrumTime = i[0];
	var daSus = i[2];
	var daLift = i[4];
	
	var note = new EdtNote(daStrumTime, daNoteInfo, daLift);
	if (daSus != null)
	{
		note.sustainLength = daSus;
	}
	else
	{
		note.loadGraphic(FNFAssets.getGraphicData(SUtil.getPath() + 'assets/images/eventArrow.png'));
		note.eventName = getEventName(i[1]);
		note.eventLength = i[1].length;
		if(i[1].length < 3)
		{
			note.eventVal1 = i[1][0][1];
			note.eventVal2 = i[1][0][2];
			note.eventVal3 = i[1][0][3];
		}
		note.noteData = -1;
		daNoteInfo = -1;
	}
	note.setGraphicSize(GRID_SIZE, GRID_SIZE);
	note.updateHitbox();
	note.x = Math.floor((daNoteInfo % (Main.ammo[_song.mania] * 2)) * GRID_SIZE) + GRID_SIZE;

	var leinst;
	leinst = _song.notes[curSection].lengthInSteps;

	if (leinst == null)
		leinst = 16;

	note.y = getYfromStrumNotes((daStrumTime - sectionStartTime(0)) % (Conductor.stepCrochet * leinst));

	return note;
}

function getEventName(names)
{
	var retStr = '';
	var addedOne = false;
	for (i in 0...names.length)
	{
		if(addedOne) retStr += ', ';
		retStr += names[i][0];
		addedOne = true;
	}
	return retStr;
}

function addSection(lengthInSteps)
{
	var sec = {
		lengthInSteps: lengthInSteps,
		bpm: _song.bpm,
		changeBPM: false,
		mustHitSection: true,
		sectionNotes: [],
		typeOfSection: 0,
		altAnim: false,
		altAnimNum: 0,
		crossfadeBf: false,
		crossfadeDad: false
	};

	_song.notes.push(sec);
}

function selectNote(note)
{

	var noteDataToCheck = note.noteData;

	if(noteDataToCheck > -1)
	{
		if(note.mustPress != _song.notes[curSection].mustHitSection) noteDataToCheck += Main.ammo[_song.mania];
		for (i in _song.notes[curSection].sectionNotes)
		{
			if (i != curSelectedNote && i.length > 2 && i[0] == note.strumTime && i[1] == noteDataToCheck)
			{
				curSelectedNote = i;
				break;
			}
		}
	}
	else
	{
		for (i in _song.events)
		{
			if(i != curSelectedNote && i[0] == note.strumTime)
			{
				curSelectedNote = i;
				curEventSelected = Std.int(curSelectedNote[1].length) - 1;
				changeEventSelected(0);
				break;
			}
		}
	}

	updateGrid();
	updateNoteUI();
}

function deleteNote(note)
{
	//if (note. != ) 
	if(note.noteData > -1) //Normal Notes
	{
		for (i in _song.notes[curSection].sectionNotes)
		{
			if (i[0] == note.strumTime && i[1] % 8 == note.noteData % 8)
			{
				FlixG.log.add('FOUND EVIL NUMBER');
				_song.notes[curSection].sectionNotes.remove(i);
			}
		}
	}
	else //Events
	{
		for (i in _song.events)
		{
			if(i[0] == note.strumTime)
			{
				if(i == curSelectedNote)
				{
					curSelectedNote = null;
					changeEventSelected(0);
				}
				//FlxG.log.add('FOUND EVIL EVENT');
				_song.events.remove(i);
				break;
			}
		}
	}

	updateGrid();
}

function clearSection()
{
	_song.notes[curSection].sectionNotes = [];

	updateGrid();
}

function clearSong()
{
	for (daSection in 0..._song.notes.length)
	{
		_song.notes[daSection].sectionNotes = [];
	}

	updateGrid();
}

function addNote()
{
	var noteStrum = getStrumTime(dummyArrow.y,false) + sectionStartTime(0);
	var noteData = Math.floor((FlixG.mouse.x - GRID_SIZE) / GRID_SIZE);
	var noteSus = 0;
	var limit = Main.ammo[_song.mania] * 2;
	if (noteData > -1)
	{
		switch (noteType) {
			case Normal: 
				// nothing
			case Mine: 
				noteData += limit;
			case Lift: 
				noteData += limit*2;
			case Death: 
				noteData += limit*3;
			default: 
				noteData += limit * noteType;
		}
	}

	if (noteData > -1)
	{
		_song.notes[curSection].sectionNotes.push([noteStrum, noteData, noteSus, false, useLiftNote]);
		curSelectedNote = _song.notes[curSection].sectionNotes[_song.notes[curSection].sectionNotes.length - 1];
	}
	else 
	{
		var event = eventStuff[Std.parseInt(eventDropDown.selectedId)][0];
		var text1 = value1InputText.text;
		var text2 = value2InputText.text;
		var text3 = value3InputText.text;
		_song.events.push([noteStrum, [[event, text1, text2, text3]]]);
		curSelectedNote = _song.events[_song.events.length - 1];
		curEventSelected = 0;
		changeEventSelected(0);
	}

	if (FlxG.keys.pressed.CONTROL && noteData > -1)
	{
		_song.notes[curSection].sectionNotes.push([noteStrum, (noteData + Main.ammo[_song.mania]) % (Main.ammo[_song.mania] * 2), noteSus, false, useLiftNote]);
	}

	trace(noteStrum);
	trace(curSection);

	updateGrid();
	updateNoteUI();

	autosaveSong();
}

function getStrumTime(yPos,doZoomCalc)
{
	var leZoom = zoomList[curZoom];
	if(!doZoomCalc) leZoom = 1;
	return FlxMath.remapToRange(yPos, gridBG.y, gridBG.y + gridBG.height * leZoom, 0, 16 * Conductor.stepCrochet);
}

function getYfromStrum(strumTime,doZoomCalc)
{
	var leZoom = zoomList[curZoom];
	if(!doZoomCalc) leZoom = 1;
	return FlxMath.remapToRange(strumTime, 0, 16 * Conductor.stepCrochet, gridBG.y, gridBG.y + gridBG.height * leZoom);
}
function getYfromStrumNotes(strumTime)
	{
		var value = strumTime / (4 * 4 * Conductor.stepCrochet);
		return GRID_SIZE * 4 * 4 * zoomList[curZoom] * value + gridBG.y;
	}
var daSpacing = 0.3;

function loadLevel()
{
	trace(_song.notes);
}

function getNotes()
{
	var noteData = [];

	for (i in _song.notes)
	{
		noteData.push(i.sectionNotes);
	}

	return noteData;
}

function loadJson(song)
{
	var proceed = true;
	var diffSuxx = '-' + diffDropDown.selectedLabel.toLowerCase();
	if (diffSuxx == '-normal') {diffSuxx = '';}

	if (_song.song.toLowerCase() == 'amnesia')
		proceed = false;

	if (_song.song.toLowerCase() == 'discharge')
		proceed = false;

	if (_song.song.toLowerCase() == 'triple-trouble')
		proceed = false;

	if (!FNFAssets.exists(SUtil.getPath() + 'assets/data/' + _song.song.toLowerCase() + '/' + _song.song.toLowerCase() + diffSuxx + '.json'))
		proceed = false;
	
	if (proceed)
	{
		var poop = song.toLowerCase() + diffSuxx;
		PlayState.SONG = Song.loadFromJson(poop, song.toLowerCase());
		PlayState.storyDifficulty = curDifficulty; //Std.parseInt(diffDropDown.selectedId);
		FlixG.resetState();
	}
	else //Prevents enter to the song in charting mode (i catched bitches)
	{
		FlxG.sound.play(FNFAssets.getSound(SUtil.getPath() + 'assets/sounds/ANGRY.ogg'));
	}
}

function loadAutosave()
{
	PlayState.SONG = Song.parseJSONshit(FlixG.save.data.autosave);
	FlixG.resetState();
}

function autosaveSong()
{
	FlixG.save.data.autosave = CoolUtil.stringifyJson({
		song: _song
	});
	FlixG.save.flush();
}

function clearEvents() {
	_song.events = [];
	updateGrid();
}

function saveLevel()
{
	_song.events.sort(sortByTime);
	var json = {
		song: _song
	};

	var data = CoolUtil.stringifyJson(json);

	if ((data != null) && (data.length > 0))
	{
		FNFAssets.askToSave(_song.song.toLowerCase() + '.json', data);
	}
}

function sortByTime(Obj1, Obj2)
{
	return FlxSort.byValues(FlxSort.ASCENDING, Obj1[0], Obj2[0]);
}

function arrayIsEmpty(theArr)
{
	if (theArr == [] || theArr == null)
		return true;

	return false;
}

function saveEvents()
{
	_song.events.sort(sortByTime);

	var eventsSong = {
		song: _song.song,
		notes: [],
		events: _song.events,
		bpm: _song.bpm,
		needsVoices: _song.needsVoices,
		player1: _song.player1,
		player2: _song.player2,
		stage: _song.stage,
		gf: _song.gf,
		isHey: _song.isHey,
		speed: _song.speed,
		isSpooky: _song.isSpooky,
		isMoody: _song.isMoody,
		cutsceneType: _song.cutsceneType,
		uiType: _song.uiType,
		isCheer: _song.isCheer,
		preferredNoteAmount: _song.preferredNoteAmount,
		forceJudgements: false,
		convertMineToNuke: false,
		mania: _song.mania
	};

	var json = {
		song: eventsSong
	}

	var data = CoolUtil.stringifyJson(json);

	if ((data != null) && (data.length > 0))
	{
		FNFAssets.askToSave('events.json', data);
	}
}